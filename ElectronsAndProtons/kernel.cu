#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include "kernel.h"
#include <stdio.h>
#include "helper_cuda.h"
#include <cassert>
#include <iostream>
#include <thrust/sort.h>
#include <thrust/device_ptr.h>
#include <thrust/execution_policy.h>


__device__ int CalculateGridRow(const float y, float cells_height)
{
	float distanceFromUpperWall = fabsf(1.0f - y);
	return distanceFromUpperWall / (cells_height + 0.001f);
}

__device__ int CalculateGridColumn(const float x, float cells_width)
{
	float distanceFromLeftWall = fabsf(-1.0f - x);
	return distanceFromLeftWall / (cells_width + 0.001f);
}

__global__ void updateParticlesKernel(
	float* particles,
	int* charges, 
	float2* positions, 
	float2* velocities, 
	float2* accelerations, 
	float2* field,
	const int particlesCount, 
	float dt,
	const float aspectRatio,
	const int width,
	const int height)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx >= particlesCount)
		return;

	if (charges[idx] > 2.0f)
		return;

	float2 position = positions[idx];


	if (position.x >= 1.0f || position.x <= -1.0f)
	{
		velocities[idx].x *= -1;
	}

	if (position.y >= 1.0f || position.y <= -1.0f)
	{
		velocities[idx].y *= -1;
	}

	float2 velocity = velocities[idx];

	float positionX = position.x + velocity.x * dt;
	float positionY = position.y + velocity.y * dt;

	positions[idx].x = positionX;
	positions[idx].y = positionY;

	particles[idx * 3] = positionX;
	particles[idx * 3 + 1] = positionY;

	int2 pixel =
	{
		(int)roundf((position.x / aspectRatio + 1.0f) * (width - 1) / 2.0f),
		(int)roundf((position.y + 1.0f) * (height - 1) / 2.0f)
	};

	int positionIdx = pixel.x + pixel.y * width;
	if (positionIdx >= width * height)
		return;
	int charge = charges[idx];

	//the below probably causes thread divergence but is it significant enough
	float mass = charge > 0 ? 18360: 1000;

	accelerations[idx].x = charge * field[positionIdx].x/mass;
	accelerations[idx].y = charge * field[positionIdx].y/mass;

	velocities[idx].x += accelerations[idx].x * dt;
	velocities[idx].y += accelerations[idx].y * dt;
}


__device__
unsigned char clip(int n)
{
	return n > 255 ? 255 : (n < 0 ? 0 : n);
}



__global__ void intensityKernel(
	uchar3* grid,
	float2* field, 
	const int width,
	const int height, 
	const float2* positions, 
	const int* charges, 
	const int particlesCount,
	const float aspectRatio,
	const float cells_width,
	const float cells_height,
	const int2* bins_to_check,
	const int bins_to_check_size,
	const int grid_columns_count,
	const int grid_rows_count,
	const int* particles_grid_cells,
	const int2* grid_cells_indices)
{
	int column = blockIdx.x * blockDim.x + threadIdx.x;
	int row = blockIdx.y * blockDim.y + threadIdx.y;

	if (column >= width || row >= height)
		return;

	float2 pixelPosition =
	{
		(column / (float)(width - 1) * 2.0f - 1.0f)* aspectRatio,
		(row / (float)(height - 1) * 2.0f - 1.0f)
	};

	int grid_row = CalculateGridRow(pixelPosition.y, cells_height);
	int grid_column = CalculateGridColumn(pixelPosition.x, cells_width);

	float3 totalIntensity = {};
	int idx = row * width + column;
	
	
	for (int i = 0; i < bins_to_check_size; i++)
	{
		int bin_column = grid_column + bins_to_check[i].x;
		int bin_row = grid_row + bins_to_check[i].y;
		if (bin_column >= 0 && bin_column < grid_columns_count && bin_row >= 0 && bin_row <= grid_rows_count)
		{
			//starting and ending index of all particles in a bin
			int2 bin_grid_cells_indices = grid_cells_indices[bin_column + bin_row * grid_columns_count];
			for (int i = bin_grid_cells_indices.x; i <= bin_grid_cells_indices.y; i++)
			{
				float2 pos = positions[i];
				float dx = pixelPosition.x - pos.x;
				float dy = pixelPosition.y - pos.y;

				float distance = sqrtf(dx * dx + dy * dy);

				float scalarIntensity = charges[i] /distance;

				// totalIntensity.z is for visual while x,y are used in further computation
				// so i dont want to later use field intensity generated by particle to move itself
				// but i want to display more intense color in that area
				totalIntensity.z += scalarIntensity;
				if (distance < 0.01f)
					continue;

				totalIntensity.x += scalarIntensity * (dx / distance);
				totalIntensity.y += scalarIntensity * (dy / distance);
			}
		}
	}

	/*
	for (int i = 0; i < particlesCount; i++)
	{
		float2 pos = positions[i];
		float dx = pixelPosition.x - pos.x;
		float dy = pixelPosition.y - pos.y;

		float distance = sqrtf(dx * dx + dy * dy);
		float invDistance = 1 / distance;

		float scalarIntensity = charges[i] * invDistance;

		// totalIntensity.z is for visual while x,y are used in further computation
		// so i dont want to later use field intensity generated by particle to move itself
		// but i want to display more intense color in that area
		totalIntensity.z += scalarIntensity;
		if (distance < 0.01f)
			continue;

		totalIntensity.x += scalarIntensity * (dx * invDistance);
		totalIntensity.y += scalarIntensity * (dy * invDistance);
	}*/
	
	float intensity = totalIntensity.z;
	field[idx].x = totalIntensity.x/ 100.0f;
	field[idx].y = totalIntensity.y/ 100.0f;

	if (intensity < 0)
	{
		intensity *= -10;
		grid[idx].z = clip(intensity);
		grid[idx].x = 0;
	}
	else
	{
		intensity *= 10;
		grid[idx].x = clip(intensity);
		grid[idx].z = 0;
	}
}

#define BLUR_RADIUS 2
__global__ void BluringKernel(uchar3* grid, int width, int height)
{
	int column = threadIdx.x + blockDim.x * blockIdx.x;
	int row = threadIdx.y + blockDim.y * blockIdx.y;

	int index = column + row * width;
	int n = width * height;
	if (index < n)
	{
		int accumulatedPixelValueR = 0;
		int accumulatedPixelValueB = 0;

		int pixelsUsed = 0;
		for (int x_offset = -BLUR_RADIUS; x_offset < BLUR_RADIUS; x_offset++)
		{
			for (int y_offset = -BLUR_RADIUS; y_offset < BLUR_RADIUS; y_offset++)
			{
				int computedIndex = index + x_offset + y_offset * width;
				if (computedIndex >= 0 && computedIndex < n)
				{
					accumulatedPixelValueR += grid[computedIndex].x;
					accumulatedPixelValueB += grid[computedIndex].z;
					pixelsUsed++;
				}
			}
		}
		accumulatedPixelValueR /= pixelsUsed;
		accumulatedPixelValueB /= pixelsUsed;

		grid[index].x = accumulatedPixelValueR;
		grid[index].z = accumulatedPixelValueB;
	}
}


__global__ void CalculateCellNumbers(
	const float* particles, 
	const int particlesCount, 
	int* particle_cells, 
	const float cells_width, 
	const float cells_height,
	const int grid_columns_count,
	const int grid_rows_count) 
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx >= particlesCount)
		return;

	float particleX = particles[idx * 3];
	float particleY = particles[idx * 3 + 1];

	int column = CalculateGridColumn(particleX, cells_width);
	int row = CalculateGridRow(particleY, cells_height);

	//printf("x=%f, y=%f, column = %d, row=%d, cells_width=%f, cells_height=%f, grid_column=%d, grid_row=%d\n", particleX, particleY, column, row, cells_width, cells_height, grid_columns_count, grid_rows_count);
	//assert(false);

	int i = column + row * grid_columns_count;

	if (column >= grid_columns_count || row >= grid_rows_count)
	{
		particle_cells[idx] = grid_columns_count * grid_rows_count;
		return;
	}

	particle_cells[idx] = i;
}

__global__ void VerifyThatSorted(int* keys, int N)
{
	int currentValue = -1;
	for (int i = 0; i < N; i++)
	{
		if (keys[i] < currentValue)
		{
			assert(false);
		}
	}
}

template <typename T>
__host__ void SortByKeys(int* keys, T* values, int N)
{
	int* keysCopy;
	cudaMalloc((void**)&keysCopy, N * sizeof(int));
	cudaMemcpy(keysCopy, keys, N * sizeof(int), cudaMemcpyDeviceToDevice);
	auto keys_device_pointer = thrust::device_ptr<int>(keysCopy);
	auto values_device_pointer = thrust::device_ptr<T>(values);

	thrust::stable_sort_by_key(thrust::device, keys_device_pointer, keys_device_pointer + N, values_device_pointer);

	VerifyThatSorted << <1, 1 >> > (keysCopy, N);
	cudaFree(keysCopy);
}

__host__ void SortParticleDataByGridCells(int* particles_grid_cells, ElectricField* field)
{ 
	SortByKeys<float2>(particles_grid_cells, field->positions_d, field->particles_count);
	SortByKeys<float2>(particles_grid_cells, field->accelerations_d, field->particles_count);
	SortByKeys<float2>(particles_grid_cells, field->velocities_d, field->particles_count);
	SortByKeys<int>(particles_grid_cells, field->charges_d, field->particles_count);
}

__global__ void AssertParticleCellsInitialized(const int particlesCount,
	int* particle_cells)
{
	for (int i = 0; i < particlesCount; i++)
	{
		if (particle_cells[i] == -1)
			printf("unitialied particle cell");
	}
}


__global__ void GetStartingAndEndingIndicesOfGridCells(
	const int* particle_cells, 
	int2* grid_cells_indices,
	const int particlesCount,
	const int N,
	const int width)
{
	int column = blockDim.x * blockIdx.x + threadIdx.x;
	int row = blockDim.y * blockIdx.y + threadIdx.y;

	int idx = column + row * width;
	if (idx >= N)
		return;

	int begining = -1;
	int ending = -2;

	for(int i=0;i<particlesCount;i++)
	{
		if (particle_cells[i] == idx)
		{
			if (begining == -1)
				begining = i;
			ending = i;
		}
	}
	grid_cells_indices[idx] = { begining,ending };
}

__host__ void updateField(
	float* particles, 
	uchar3* grid, 
	ElectricField* field, 
	int particlesCount, 
	float dt, 
	int width, 
	int height)
{

	// mapping onto opengl plane with coords (-1;1)
	float planeWidth = 2;
	float planeHeight = 2;
	float grid_column_height = planeHeight /field->grid_columns;
	float grid_row_width = planeWidth /field->grid_rows;
	dim3 calculateCellNumsBlockDimensions = dim3(1024);
	dim3 calculateCellNumsGridDimensions = dim3((particlesCount + 1024 - 1) / 1024);
	CalculateCellNumbers << <calculateCellNumsGridDimensions, calculateCellNumsBlockDimensions >> > (
		particles,
		particlesCount,
		field->particles_grid_cells_d,
		grid_row_width,
		grid_column_height,
		field->grid_columns,
		field->grid_rows);

	cudaError_t err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << cudaGetErrorString(err) << std::endl;
		//assert(false);
	}

	SortParticleDataByGridCells(field->particles_grid_cells_d, field);

	int2* grid_cells_indices;
	cudaMalloc((void**)&grid_cells_indices, sizeof(int2) * field->grid_columns * field->grid_rows);

	dim3 indicesCalculationBlockDim = dim3(32,32);
	dim3 gridDim = dim3((field->grid_columns - 1 + 32) / 32, (field->grid_rows - 1 + 32) / 32);
	GetStartingAndEndingIndicesOfGridCells << <gridDim, indicesCalculationBlockDim >> > (
		field->particles_grid_cells_d, 
		grid_cells_indices,
		particlesCount,
		field->grid_columns * field->grid_rows, 
		field->grid_columns);
		

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << cudaGetErrorString(err) << std::endl;
		//assert(false);
	}

	

	float aspectRatio = width / height;
	int blockX = 16;
	int blockY = 16;
	dim3 intensityBlockDim = dim3(blockX, blockY);
	dim3 intensityKernelGridDim = dim3((width + blockX - 1) / blockX, (height + blockY - 1) / blockY);
	intensityKernel<<<intensityKernelGridDim, intensityBlockDim>>>(
		grid, 
		field->field_d, 
		width, 
		height, 
		field->positions_d, 
		field->charges_d, 
		particlesCount,
		aspectRatio,
		grid_row_width,
		grid_column_height,
		field->bins_d,
		field->bins_to_check_count,
		field->grid_columns,
		field->grid_rows,
		field->particles_grid_cells_d,
		grid_cells_indices);

	/*void intensityKernel(
	uchar3* grid,
	float2* field, 
	const int width,
	const int height, 
	const float2* positions, 
	const int* charges, 
	const int particlesCount,
	const float aspectRatio,
	const float cells_width,
	const float cells_height)*/

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << cudaGetErrorString(err) << std::endl;
		//assert(false);
	}

	dim3 blockDimensions = dim3(1024);
	dim3 updateKernelGridDimensions = dim3((particlesCount + 1024 - 1) / 1024);

	updateParticlesKernel<<<updateKernelGridDimensions, blockDimensions>>>(
		particles,
		field->charges_d, 
		field->positions_d, 
		field->velocities_d,
		field->accelerations_d,
		field->field_d,
		particlesCount, 
		dt,
		aspectRatio,
		width,
		height);

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << cudaGetErrorString(err) << std::endl;
		//assert(false);
	}

	dim3 bluringBlock = dim3(32, 32);
	dim3 bluringGridDim = dim3((width + 32 - 1) / 32, (height + 32 - 1) / 32);
	BluringKernel << <bluringGridDim, bluringBlock >> > (grid, width, height);

	cudaFree(grid_cells_indices);
}