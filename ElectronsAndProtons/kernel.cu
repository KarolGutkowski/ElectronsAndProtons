#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include "kernel.h"
#include <stdio.h>
#include "helper_cuda.h"
#include <cassert>
#include <iostream>
#include <thrust/sort.h>
#include <thrust/device_ptr.h>
#include <thrust/execution_policy.h>
#include <thrust/device_malloc_allocator.h>
#include "gputimer.h"

__device__ int CalculateGridRow(const float y, float cells_height)
{
	float distanceFromUpperWall = fabsf(1.0f - y);
	if (distanceFromUpperWall == 2.0f)
	{
		return  distanceFromUpperWall / (cells_height) -1;
	}
	return distanceFromUpperWall / (cells_height);
}

__device__ int CalculateGridColumn(const float x, float cells_width)
{
	float distanceFromLeftWall = fabsf(-1.0f - x);

	if (distanceFromLeftWall == 2.0f)
	{
		return distanceFromLeftWall / (cells_width) -1;
	}

	return distanceFromLeftWall / (cells_width);
}

__global__ void updateParticlesKernel(
	float* particles,
	int* charges, 
	float2* positions, 
	float2* velocities, 
	float2* accelerations, 
	float2* field,
	const int particlesCount, 
	float dt,
	const float aspectRatio,
	const int width,
	const int height)
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx >= particlesCount)
		return;

	float2 position = positions[idx];

	if (position.x >= 1.0f || position.x <= -1.0f)
	{
		velocities[idx].x *= -1;
	}

	if (position.y >= 1.0f || position.y <= -1.0f)
	{
		velocities[idx].y *= -1;
	}

	float2 velocity = velocities[idx];

	float positionX = position.x + velocity.x * dt;
	float positionY = position.y + velocity.y * dt;

	positions[idx].x = positionX;
	positions[idx].y = positionY;

	particles[idx * 3] = positionX;
	particles[idx * 3 + 1] = positionY;

	int2 pixel =
	{
		(int)roundf((position.x + 1.0f) * (width - 1) / 2.0f),
		(int)roundf((position.y + 1.0f) * (height - 1) / 2.0f)
	};

	int positionIdx = pixel.x + pixel.y * width;
	if (pixel.x >= width || pixel.y >= height || positionIdx >= width * height)
		return;
	int charge = charges[idx];

	//the below probably causes thread divergence but is it significant enough
	float mass = charge > 0 ? 18360: 1000;

	accelerations[idx].x = charge * field[positionIdx].x/mass;
	accelerations[idx].y = charge * field[positionIdx].y/mass;

	velocities[idx].x += accelerations[idx].x * dt;
	velocities[idx].y += accelerations[idx].y * dt;
}


__device__
unsigned char clip(int n)
{
	return n > 255 ? 255 : (n < 0 ? 0 : n);
}



__global__ void intensityKernel(
	uchar3* grid,
	float2* field, 
	const int width,
	const int height, 
	const float2* positions, 
	const int* charges, 
	const int particlesCount,
	const float aspectRatio,
	const float cells_width,
	const float cells_height,
	const int2* bins_to_check,
	const int bins_to_check_size,
	const int grid_columns_count,
	const int grid_rows_count,
	const int2* grid_cells_indices,
	SimulationScenario scenario)
{
	int column = blockIdx.x * blockDim.x + threadIdx.x;
	int row = blockIdx.y * blockDim.y + threadIdx.y;

	if (column >= width || row >= height)
		return;

	float2 pixelPosition =
	{
		(column / (float)(width - 1) * 2.0f - 1.0f),
		(row / (float)(height - 1) * 2.0f - 1.0f)
	};

	float3 totalIntensity = {};
	
	for (int i = 0; i < bins_to_check_size; i++)
	{
		int bin_column = CalculateGridColumn(pixelPosition.x, cells_width) + bins_to_check[i].x;
		int bin_row = CalculateGridRow(pixelPosition.y, cells_height) + bins_to_check[i].y;
		if (bin_column >= 0 && bin_column < grid_columns_count && bin_row >= 0 && bin_row < grid_rows_count)
		{
			//starting and ending index of all particles in a bin
			int2 bin_grid_cells_indices = grid_cells_indices[bin_column + bin_row * grid_columns_count];
			for (int i = bin_grid_cells_indices.x; i <= bin_grid_cells_indices.y; i++)
			{
				float2 pos = positions[i];
				float dx = pixelPosition.x - pos.x;
				float dy = pixelPosition.y - pos.y;

				float scalarIntensity = charges[i] / sqrtf(dx * dx + dy * dy);

				if (sqrtf(dx * dx + dy * dy) > 4.25f * cells_width)
					continue;

				// totalIntensity.z is for visual while x,y are used in further computation
				// so i dont want to later use field intensity generated by particle to move itself
				// but i want to display more intense color in that area
				totalIntensity.z += scalarIntensity;
				if (sqrtf(dx * dx + dy * dy) < 0.01f)
					continue;

				totalIntensity.x += scalarIntensity * (dx / sqrtf(dx * dx + dy * dy));
				totalIntensity.y += scalarIntensity * (dy / sqrtf(dx * dx + dy * dy));
			}
		}
	}

	//symulacja ładunku w środku
	/*if (scenario == SimulationScenario::CenterCharge && pixelPosition.x != 0 && pixelPosition.y != 0)
	{
		float distanceToCenter = sqrtf(pixelPosition.x * pixelPosition.x + pixelPosition.y * pixelPosition.y);
		float scalarIntensity = 100 / distanceToCenter;
		totalIntensity.z += scalarIntensity;
		totalIntensity.x += scalarIntensity * (pixelPosition.x / distanceToCenter);
		totalIntensity.y += scalarIntensity * (pixelPosition.y / distanceToCenter);
	}
	else if (scenario == SimulationScenario::TwoEdgeCharges &&  pixelPosition.y != 0 && (pixelPosition.x != -1 || pixelPosition.x != 1))
	{
		float dxR = pixelPosition.x - 1;
		float dxL = pixelPosition.x + 1;

		float distanceToLeft = sqrtf(dxL * dxL + pixelPosition.y * pixelPosition.y);
		float distanceToRight = sqrtf(dxR * dxR + pixelPosition.y * pixelPosition.y);
		float intensityFromLeft = 100 / distanceToLeft;
		float intensityFromRight = -100 / distanceToRight;


		totalIntensity.z += intensityFromLeft + intensityFromRight;
		totalIntensity.x += intensityFromLeft * (pixelPosition.x / distanceToLeft) + intensityFromRight * (pixelPosition.x / distanceToRight);
		totalIntensity.y += intensityFromLeft * (pixelPosition.y / distanceToLeft) + intensityFromRight * (pixelPosition.y / distanceToRight);

	}*/

	// idx = row * width + column - using the right hand to save few registers
	float intensity = totalIntensity.z;
	field[row * width + column].x = totalIntensity.x/ 100.0f;
	field[row * width + column].y = totalIntensity.y/ 100.0f;

	if (intensity < 0)
	{
		intensity *= -1;
		grid[row * width + column].z = clip(intensity);
		grid[row * width + column].x = 0;
	}
	else
	{
		grid[row * width + column].x = clip(intensity);
		grid[row * width + column].z = 0;
	}
}

#define BLUR_RADIUS 2
__global__ void BluringKernel(uchar3* grid, int width, int height)
{
	int column = threadIdx.x + blockDim.x * blockIdx.x;
	int row = threadIdx.y + blockDim.y * blockIdx.y;

	int index = column + row * width;
	int n = width * height;
	if (index < n)
	{
		int accumulatedPixelValueR = 0;
		int accumulatedPixelValueB = 0;

		int pixelsUsed = 0;
		for (int x_offset = -BLUR_RADIUS; x_offset < BLUR_RADIUS; x_offset++)
		{
			for (int y_offset = -BLUR_RADIUS; y_offset < BLUR_RADIUS; y_offset++)
			{
				int computedIndex = index + x_offset + y_offset * width;
				if (computedIndex >= 0 && computedIndex < n)
				{
					accumulatedPixelValueR += grid[computedIndex].x;
					accumulatedPixelValueB += grid[computedIndex].z;
					pixelsUsed++;
				}
			}
		}
		accumulatedPixelValueR /= pixelsUsed;
		accumulatedPixelValueB /= pixelsUsed;

		grid[index].x = accumulatedPixelValueR;
		grid[index].z = accumulatedPixelValueB;
	}
}


__global__ void CalculateCellNumbers(
	const float* particles, 
	const int particlesCount, 
	int* particle_cells, 
	const float cells_width, 
	const float cells_height,
	const int grid_columns_count,
	const int grid_rows_count) 
{
	int idx = blockIdx.x * blockDim.x + threadIdx.x;
	if (idx >= particlesCount)
		return;

	float particleX = particles[idx * 3];
	float particleY = particles[idx * 3 + 1];

	int column = CalculateGridColumn(particleX, cells_width);
	int row = CalculateGridRow(particleY, cells_height);

	//printf("x=%f, y=%f, column = %d, row=%d, cells_width=%f, cells_height=%f, grid_column=%d, grid_row=%d\n", particleX, particleY, column, row, cells_width, cells_height, grid_columns_count, grid_rows_count);
	//assert(false);

	int i = column + row * grid_columns_count;

	if (column >= grid_columns_count || row >= grid_rows_count)
	{
		particle_cells[idx] = grid_columns_count * grid_rows_count;
		return;
	}

	particle_cells[idx] = i;
}

__global__ void PrintValues(int* keys, int N)
{
	for (int i = 0; i < N; i++)
	{
		printf("keys[%d]=%d\n", i, keys[i]);
	}
}

template <typename T>
__host__ void SortByKeys(int* keys, T* values, int N)
{
	int* keysCopy;
	cudaMalloc((void**)&keysCopy, N * sizeof(int));
	cudaMemcpy(keysCopy, keys, N * sizeof(int), cudaMemcpyDeviceToDevice);
	auto keys_device_pointer = thrust::device_pointer_cast(keysCopy);
	auto values_device_pointer = thrust::device_pointer_cast(values);

	thrust::stable_sort_by_key(thrust::device, keys_device_pointer, keys_device_pointer + N, values_device_pointer);
	cudaFree(keysCopy);
}

__host__ void SortParticleDataByGridCells(int* particles_grid_cells, ElectricField* field)
{ 
	SortByKeys<float2>(particles_grid_cells, field->positions_d, field->particles_count);
	SortByKeys<float2>(particles_grid_cells, field->accelerations_d, field->particles_count);
	SortByKeys<float2>(particles_grid_cells, field->velocities_d, field->particles_count);
	SortByKeys<int>(particles_grid_cells, field->charges_d, field->particles_count);
}

__global__ void AssertParticleCellsInitialized(const int particlesCount,
	int* particle_cells)
{
	for (int i = 0; i < particlesCount; i++)
	{
		if (particle_cells[i] == -1)
			printf("unitialied particle cell");
	}
}


__global__ void PrintRangesForGridCells(int2* grid_cells_indices, int grid_cells_count)
{
	for (int i = 0; i < grid_cells_count; i++)
	{
		printf("grid cell no. %d starts at %d and ends at %d\n", i, grid_cells_indices[i].x, grid_cells_indices[i].y);
	}
}

__global__ void GetStartingAndEndingIndicesOfGridCells(
	const int* particle_cells, 
	int2* grid_cells_indices,
	const int particlesCount,
	const int N,
	const int width)
{
	int column = blockDim.x * blockIdx.x + threadIdx.x;
	int row = blockDim.y * blockIdx.y + threadIdx.y;

	int idx = column + row * width;
	if (idx >= N)
		return;

	int begining = -1;
	int ending = -2;

	for(int i=0;i<particlesCount;i++)
	{
		if (particle_cells[i] == idx)
		{
			if (begining == -1)
				begining = i;
			ending = i;
		}
	}

	//printf("grid_cells_indices[%d]={%d, %d}\n", idx, begining, ending);
	grid_cells_indices[idx] = { begining,ending };
}


__host__ void LaunchCalculateCellNumbersKernel(ElectricField* field, int particlesCount, float* particles)
{
	float planeWidth = 2;
	float planeHeight = 2;
	float grid_column_height = planeHeight / field->grid_columns;
	float grid_row_width = planeWidth / field->grid_rows;
	dim3 calculateCellNumsBlockDimensions = dim3(1024);
	dim3 calculateCellNumsGridDimensions = dim3((particlesCount + 1024 - 1) / 1024);
	CalculateCellNumbers << <calculateCellNumsGridDimensions, calculateCellNumsBlockDimensions >> > (
		particles,
		particlesCount,
		field->particles_grid_cells_d,
		grid_row_width,
		grid_column_height,
		field->grid_columns,
		field->grid_rows);

	auto err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}
}

int measurements_count = 0;
float sum_of_time_measurements = 0.0f;
__host__ void updateField(
	float* particles, 
	uchar3* grid, 
	ElectricField* field, 
	int particlesCount, 
	float dt, 
	int width, 
	int height)
{
	float planeWidth = 2;
	float planeHeight = 2;
	float grid_column_height = planeHeight / field->grid_columns;
	float grid_row_width = planeWidth / field->grid_rows;
	dim3 calculateCellNumsBlockDimensions = dim3(1024);
	dim3 calculateCellNumsGridDimensions = dim3((particlesCount + 1024 - 1) / 1024);
	CalculateCellNumbers << <calculateCellNumsGridDimensions, calculateCellNumsBlockDimensions >> > (
		particles,
		particlesCount,
		field->particles_grid_cells_d,
		grid_row_width,
		grid_column_height,
		field->grid_columns,
		field->grid_rows);

	auto err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}

	SortParticleDataByGridCells(field->particles_grid_cells_d, field);

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}

	int2* grid_cells_indices;
	checkCudaErrors(cudaMalloc((void**)&grid_cells_indices, sizeof(int2) * field->grid_columns * field->grid_rows));

	dim3 indicesCalculationBlockDim = dim3(32,32);
	dim3 gridDim = dim3((field->grid_columns - 1 + 32) / 32, (field->grid_rows - 1 + 32) / 32);
	GetStartingAndEndingIndicesOfGridCells << <gridDim, indicesCalculationBlockDim >> > (
		field->particles_grid_cells_d, 
		grid_cells_indices,
		particlesCount,
		field->grid_columns * field->grid_rows, 
		field->grid_columns);

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}	

	auto timer = GpuTimer();

	timer.Start();
	float aspectRatio = width /(float) height;
	int blockX = 32;
	int blockY = 32;
	dim3 intensityBlockDim = dim3(blockX, blockY);
	dim3 intensityKernelGridDim = dim3((width + blockX - 1) / blockX, (height + blockY - 1) / blockY);
	intensityKernel << <intensityKernelGridDim, intensityBlockDim/*, 4096 * (sizeof(float2) + sizeof(int)) */ >> > (
		grid, // all the pixels im going to be displaying
		field->field_d, // data about intensity later used by particles ( x,y components)
		width, //
		height, // screen width and height, also limit of size for grid
		field->positions_d, // positions of particles in plane
		field->charges_d, // corressponding particle charge value
		particlesCount, // particles_count, upper limit for both of ararys above
		aspectRatio, // width of screen/ height of screen for converting positions to pixel coordinates
		grid_row_width, // width of one cell/bin
		grid_column_height, // height of one cell/bin
		field->bins_d, // (x,y) coordinate pairs that determine which bins at any location we may want to check
		field->bins_to_check_count, // count of the above array
		field->grid_columns, // amount of columns (amount of cells/bins)
		field->grid_rows, // same as column but for rows count
		//field->particles_grid_cells_d, // array that tells us in which grid cell a certain particle is?
		grid_cells_indices,
		SimulationScenario::Default); // array with beggining and ends of bins/cells

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}
	timer.Stop();

	sum_of_time_measurements+= timer.Elapsed();
	measurements_count++;

	if (measurements_count % 1000 ==0)
	{
		std::cout << "Average intensity kernel time: " << sum_of_time_measurements /(float) measurements_count << " ms" << std::endl;
	}


	int threadsPerBlock = 1024;
	dim3 blockDimensions = dim3(threadsPerBlock);
	dim3 updateKernelGridDimensions = dim3((particlesCount + threadsPerBlock - 1) / threadsPerBlock);

	updateParticlesKernel<<<updateKernelGridDimensions, blockDimensions>>>(
		particles,
		field->charges_d, 
		field->positions_d, 
		field->velocities_d,
		field->accelerations_d,
		field->field_d,
		particlesCount, 
		dt,
		aspectRatio,
		width,
		height);

	err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		std::cout << __LINE__ << __FILE__ << " " << cudaGetErrorString(err) << std::endl;
	}

	dim3 bluringBlock = dim3(32, 32);
	dim3 bluringGridDim = dim3((width + 32 - 1) / 32, (height + 32 - 1) / 32);
	BluringKernel << <bluringGridDim, bluringBlock >> > (grid, width, height);

	cudaFree(grid_cells_indices);

	cudaDeviceSynchronize();
}